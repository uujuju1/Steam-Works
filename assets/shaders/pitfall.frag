#define HIGHP

uniform sampler2D u_texture;
uniform sampler2D u_noise;
uniform sampler2D u_mask;

uniform vec2 u_maskprojectionuv;
uniform vec2 u_maskprojectionuv2;
uniform vec2 u_masksize;

uniform float u_scale;

uniform vec2 u_campos;
uniform vec2 u_resolution;
uniform float u_time;

varying vec2 v_texCoords;

// make sure it's an odd number so that the hitPos ends up inside the mask
const int marchPrecision = 7;


uniform sampler2D u_wall;
uniform vec4 u_walluv;
uniform vec2 u_wallsize;
uniform float u_walltilesize;


uniform sampler2D u_grating;
uniform vec4 u_gratinguv;
uniform vec2 u_gratingsize;

float rand(vec2 n) {
    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
}

float map(float value, float froma, float toa, float fromb, float tob) {
    return fromb + (value - froma) * (tob - fromb) / (toa - froma);
}
vec2 mapVec2(vec2 value, vec2 froma, vec2 toa, vec2 fromb, vec2 tob) {
    return fromb + (value - froma) * (tob - fromb) / (toa - froma);
}

vec2 projectMask(vec2 coords) {
    return mapVec2(
        coords,
        u_maskprojectionuv,
        u_maskprojectionuv2,
        vec2(0.0),
        vec2(1.0)
    );
}

vec2 raycast(vec2 center, vec2 pos, vec2 dir, float step, float maxLength) {
    vec2 hitPos = pos;

    bool reverse = false;
    int level = 0;
    for(float i = 0; i < maxLength * 2; i++) {
        if (length(hitPos - pos) > maxLength || level > marchPrecision) {
            break;
        }
        hitPos += dir * step;

        vec4 col = texture2D(u_mask, hitPos / u_masksize);

        if (
            (col.a < 0.9 && !reverse) ||
            (col.a > 0.9 && reverse)
        ) {
            reverse = !reverse;
            level++;
            step *= -0.5;
        }
    }

    return hitPos;
}

void main() {
    vec2 uv = v_texCoords;
    vec2 projectedUV = projectMask(uv);

    vec4 baseColor = texture2D(u_texture, uv);
    vec4 maskColor = texture2D(u_mask, projectedUV);

    if (maskColor.a < 0.9) {
        gl_FragColor = baseColor;
        return;
    }

    vec2 worldCoords = projectedUV * u_masksize;
    vec2 worldCenter = projectMask(vec2(0.5)) * u_masksize;

    vec2 hitPos = raycast(worldCenter, worldCoords, normalize(worldCoords - worldCenter), 8, 200.0);
    float dstPos = length(hitPos - worldCoords);
    float dstCenter = length(hitPos - worldCenter);

    float mapped = map(dstPos, 0.0, dstCenter, 0.0, 1.0);

    // in tiles
    float z = (1/(1 - mapped) - 1) * u_scale;

    gl_FragColor = vec4(0, 0, 0, 1);

    // walls
    if (z <= 32) {
        vec2 tile = floor(hitPos / 8.0);

        float offset = rand(tile) * 16;

        if (z <= 32 - offset) {
            vec2 divisions = floor(u_wallsize / u_walltilesize);
            vec2 selection = floor(vec2(rand(tile + floor(z)), rand(tile + floor(z) + 1)) * divisions);

            vec2 plateUV = vec2(mod(hitPos.x + hitPos.y, 8.0)/8.0, mod(z, 1));
            vec4 color = texture2D(u_wall, mapVec2(plateUV + selection, vec2(0.0), vec2(4.0), u_walluv.xy, u_walluv.zw));
            vec3 fade = vec3(32.0 - z)/ 32.0;
            gl_FragColor = color * vec4(fade, 1.0);
        }
    }

    // TODO fix connecting with other pitfalls
    // chasm
    if (z >= 48 && texture2D(u_mask, hitPos / u_masksize).r < 0.9) {
        float unMapped = 1 - 1/(64/u_scale + 1);
        vec2 unProjected = (worldCenter * -unMapped + worldCoords) / (vec2(1 - unMapped));

        if (
            texture2D(u_mask, unProjected / u_masksize).r < 0.9
        ) {
            float startOffset = texture2D(u_noise, hitPos / 32 + vec2(u_time, -u_time * 2)/3600).a * 8;
            float endOffset = texture2D(u_noise, hitPos / 32 + vec2(-u_time * 3, u_time)/3600).a * 8;

            float fadeNoise = 0;
            for (int i = 0; i < 4; i++) {
                float randX = rand(vec2(i, 1)) * 2 - 1;
                float randY = rand(vec2(1, i)) * 2 - 1;
                fadeNoise += texture2D(u_noise, unProjected / 128 + vec2(u_time * randX, u_time * randY)/3600).a;
            }
            fadeNoise /= 2;
            fadeNoise *= fadeNoise;

            vec3 fade = vec3(min(1, map(z, 56 - startOffset, 64 - endOffset, 0, 1)));
            gl_FragColor = vec4(fade * fadeNoise, 1.0) * vec4(115, 16, 7, 255)/255;
        }
    }

    // waterfall
    if (z <= 32 && texture2D(u_mask, hitPos / u_masksize).g < 0.9) {
        vec4 color = vec4(110.0, 112.0, 155.0, 0)/255.0;
        for(float i = 0.0; i < 3; i++) {
            float offsetX = rand(vec2(i));
            float offsetY = rand(vec2(z));
            float scl = pow(2, i);
            vec2 noiseUV = vec2((hitPos.x + hitPos.y + offsetX)/32.0, z/64/scl - u_time/120.0);
            vec4 col = texture2D(u_noise, noiseUV);
            col = pow(col, vec4(2 - z/32));

            if (col.a > 0.25) {
                color = mix(color, col, vec4(col.a));
            }
        }
        vec3 fade = vec3(32.0 - z)/ 32.0;
        if (color.r > 0) gl_FragColor = vec4(color.rgb * fade, 1.0);
    }

    // grating
    if (z >= 4) {
        float unMapped = 1 - 1/(4/u_scale + 1);
        vec2 unProjected = (worldCenter * -unMapped + worldCoords) / (vec2(1 - unMapped));

        if (texture2D(u_mask, unProjected / u_masksize).b < 0.9) {
            vec2 gratingUV = mod(unProjected * 4 / u_gratingsize, vec2(1));
            vec4 color = texture2D(u_grating, mapVec2(gratingUV, vec2(0.0), vec2(1.0), u_gratinguv.xy, u_gratinguv.zw));
            float dstPos = length(raycast(worldCenter, unProjected, vec2(0.707), 8, 40) - unProjected);
            if (color.a > 0) {
                gl_FragColor = color;
                if (dstPos < 32) gl_FragColor = vec4(mix(color.rgb, vec3(0), vec3(0.3)), 1.0);
            }
        }
    }
}
